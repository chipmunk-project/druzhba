use std::collections::HashMap;
use druzhba::packet::Packet;
use druzhba::stateful_memory::{StatefulMemory, StatefulMemories};
const ETHERTYPE_IPV6 : i32 = 0x86dd;
const VLAN_DEPTH : i32 = 4;
const ETHERTYPE_IPV4 : i32 = 0x0800;
const ETHERTYPE_RARP : i32 = 0x8035;
const IP_PROTOCOLS_ICMPV6 : i32 = 58;
const ETHERTYPE_VLAN : i32 = 0x8100;
const IP_PROTOCOLS_TCP : i32 = 6;
const IP_PROTOCOLS_UDP : i32 = 17;
const IP_PROTOCOLS_ICMP : i32 = 1;
const ETHERTYPE_ARP : i32 = 0x0806;
fn drop_pkt(pkt : &mut Packet,  stateful_memories : &mut StatefulMemories){
  drop(pkt);
  
}
fn hop_ipv4(egress_spec : i32 , pkt : &mut Packet, stateful_memories : &mut StatefulMemories){
    let mut field_0 : i32 = pkt.get_field_value ("ipv4", "ttl");
  hop(&mut field_0,egress_spec, pkt, stateful_memories);
    *pkt.get_mut_ref_field("ipv4", "ttl") = field_0;

}
fn hop(ttl : &mut i32 ,egress_spec : i32 , pkt : &mut Packet, stateful_memories : &mut StatefulMemories){
    let mut field_0 : i32 = pkt.get_field_value ("standard_metadata", "egress_spec");
  add_to_field(ttl,-1);
  modify_field(&mut field_0,egress_spec,);
    *pkt.get_mut_ref_field("standard_metadata", "egress_spec") = field_0;

}
fn act(pkt : &mut Packet,  stateful_memories : &mut StatefulMemories){
    let mut field_0 : StatefulMemory =  stateful_memories.get_memory("cnt1");
  count(&mut field_0,10);
    *stateful_memories.get_mut_ref_memory("cnt1") = field_0;

}
// Returns HashMap from  a header_type to a HashMap of header fields
pub fn header_types () -> HashMap <String, HashMap<String, i32> > { 
  let mut header_types : HashMap<String, HashMap <String, i32>> = HashMap::new();

  let mut ethernet_t_map : HashMap <String, i32> = HashMap::new();
  ethernet_t_map.insert(String::from("dstAddr"), 48);
  ethernet_t_map.insert(String::from("srcAddr"), 48);
  ethernet_t_map.insert(String::from("etherType"), 16);

  let mut vlan_tag_t_map : HashMap <String, i32> = HashMap::new();
  vlan_tag_t_map.insert(String::from("pcp"), 3);
  vlan_tag_t_map.insert(String::from("cfi"), 1);
  vlan_tag_t_map.insert(String::from("vid"), 12);
  vlan_tag_t_map.insert(String::from("etherType"), 16);

  let mut ipv4_t_map : HashMap <String, i32> = HashMap::new();
  ipv4_t_map.insert(String::from("version"), 4);
  ipv4_t_map.insert(String::from("ihl"), 4);
  ipv4_t_map.insert(String::from("diffserv"), 8);
  ipv4_t_map.insert(String::from("totalLen"), 16);
  ipv4_t_map.insert(String::from("identification"), 16);
  ipv4_t_map.insert(String::from("flags"), 3);
  ipv4_t_map.insert(String::from("fragOffset"), 13);
  ipv4_t_map.insert(String::from("ttl"), 8);
  ipv4_t_map.insert(String::from("protocol"), 8);
  ipv4_t_map.insert(String::from("hdrChecksum"), 16);
  ipv4_t_map.insert(String::from("srcAddr"), 32);

  let mut ipv6_t_map : HashMap <String, i32> = HashMap::new();
  ipv6_t_map.insert(String::from("version"), 4);
  ipv6_t_map.insert(String::from("trafficClass"), 8);
  ipv6_t_map.insert(String::from("flowLabel"), 20);
  ipv6_t_map.insert(String::from("payloadLen"), 16);
  ipv6_t_map.insert(String::from("nextHdr"), 8);
  ipv6_t_map.insert(String::from("hopLimit"), 8);
  ipv6_t_map.insert(String::from("srcAddr"), 128);
  ipv6_t_map.insert(String::from("dstAddr"), 128);

  let mut icmp_t_map : HashMap <String, i32> = HashMap::new();
  icmp_t_map.insert(String::from("hdr_type"), 8);
  icmp_t_map.insert(String::from("code"), 8);
  icmp_t_map.insert(String::from("hdrChecksum"), 16);

  let mut icmpv6_t_map : HashMap <String, i32> = HashMap::new();
  icmpv6_t_map.insert(String::from("hdr_type"), 8);
  icmpv6_t_map.insert(String::from("code"), 8);
  icmpv6_t_map.insert(String::from("hdrChecksum"), 16);

  let mut tcp_t_map : HashMap <String, i32> = HashMap::new();
  tcp_t_map.insert(String::from("srcPort"), 16);
  tcp_t_map.insert(String::from("dstPort"), 16);
  tcp_t_map.insert(String::from("seqNo"), 32);
  tcp_t_map.insert(String::from("ackNo"), 32);
  tcp_t_map.insert(String::from("dataOffset"), 4);
  tcp_t_map.insert(String::from("res"), 3);
  tcp_t_map.insert(String::from("ecn"), 3);
  tcp_t_map.insert(String::from("ctrl"), 6);
  tcp_t_map.insert(String::from("window"), 16);
  tcp_t_map.insert(String::from("checksum"), 16);
  tcp_t_map.insert(String::from("urgentPtr"), 16);

  let mut udp_t_map : HashMap <String, i32> = HashMap::new();
  udp_t_map.insert(String::from("srcPort"), 16);
  udp_t_map.insert(String::from("dstPort"), 16);
  udp_t_map.insert(String::from("hdr_length"), 16);
  udp_t_map.insert(String::from("checksum"), 16);

  let mut routing_metadata_t_map : HashMap <String, i32> = HashMap::new();
  routing_metadata_t_map.insert(String::from("drop"), 1);
  header_types.insert(String::from("ethernet_t"), ethernet_t_map);
  header_types.insert(String::from("vlan_tag_t"), vlan_tag_t_map);
  header_types.insert(String::from("ipv4_t"), ipv4_t_map);
  header_types.insert(String::from("ipv6_t"), ipv6_t_map);
  header_types.insert(String::from("icmp_t"), icmp_t_map);
  header_types.insert(String::from("icmpv6_t"), icmpv6_t_map);
  header_types.insert(String::from("tcp_t"), tcp_t_map);
  header_types.insert(String::from("udp_t"), udp_t_map);
  header_types.insert(String::from("routing_metadata_t"), routing_metadata_t_map);
  header_types
}
// Returns HashMap mapping created instance name to the declared header_type or metadata name
pub fn instances_to_types () -> HashMap <String, String> { 
  let mut instances_to_types_map : HashMap <String, String> = HashMap::new();
  instances_to_types_map.insert(String::from("routing_metadata"), String::from("routing_metadata_t"));
  instances_to_types_map.insert(String::from("ethernet"), String::from("ethernet_t"));
  instances_to_types_map.insert(String::from("vlan_tag_[VLAN_DEPTH]"), String::from("vlan_tag_t"));
  instances_to_types_map.insert(String::from("ipv4"), String::from("ipv4_t"));
  instances_to_types_map.insert(String::from("ipv6"), String::from("ipv6_t"));
  instances_to_types_map.insert(String::from("icmp"), String::from("icmp_t"));
  instances_to_types_map.insert(String::from("icmpv6"), String::from("icmpv6_t"));
  instances_to_types_map.insert(String::from("tcp"), String::from("tcp_t"));
  instances_to_types_map.insert(String::from("udp"), String::from("udp_t"));
  instances_to_types_map
}
// Returns HashMap mapping table name with type of match 
pub fn matches () -> HashMap<String, Vec<Vec<String>>>{
  let mut matches : HashMap <String, Vec<Vec<String>>> = HashMap::new();
  let mut ipv4_routing_vec : Vec<Vec<String>> = Vec::new();
  ipv4_routing_vec.push(vec![String::from("ipv4"), String::from("dstAddr"), String::from("lpm"), ]);
  let mut table_2_vec : Vec<Vec<String>> = Vec::new();
  table_2_vec.push(vec![String::from("ipv4"), String::from("dstAddr"), String::from("lpm"), ]);
  matches.insert(String::from("ipv4_routing"), ipv4_routing_vec);
  matches.insert(String::from("table_2"), table_2_vec);
  matches
}
// Returns HashMap of table names to the actions contained in them
pub fn table_name_to_actions () -> HashMap<String, Vec<String>>{
  let mut table_to_actions : HashMap <String, Vec<String>> = HashMap::new();
  let mut ipv4_routing_vec  : Vec <String> = Vec::new();
  ipv4_routing_vec.push(String::from("drop_pkt"));
  ipv4_routing_vec.push(String::from("hop_ipv4"));
  let mut table_2_vec  : Vec <String> = Vec::new();
  table_2_vec.push(String::from("act"));
  table_to_actions.insert(String::from("ipv4_routing"), ipv4_routing_vec);
  table_to_actions.insert(String::from("table_2"), table_2_vec);
  table_to_actions
}
fn counters () -> HashMap <String, HashMap <String, String>> {
  let mut counter_map : HashMap <String, HashMap <String,String>> = HashMap::new();
  let mut cnt1_map : HashMap <String, String> = HashMap::new();
  cnt1_map.insert(String::from("type"), String::from("packets"));
  cnt1_map.insert(String::from("static"), String::from("table_2"));
  cnt1_map.insert(String::from("instance_count"), String::from("32"));
  counter_map.insert(String::from("cnt1"), cnt1_map);
   counter_map
}
fn registers () -> HashMap <String, HashMap <String, String>> {
  let mut register_map : HashMap <String, HashMap <String,String>> = HashMap::new();
  let mut reg1_map : HashMap <String, String> = HashMap::new();
  reg1_map.insert(String::from("width"), String::from("20"));
  reg1_map.insert(String::from("static"), String::from("ipv4_routing"));
  reg1_map.insert(String::from("instance_count"), String::from("100"));
  reg1_map.insert(String::from("attributes"), String::from("saturating, signed"));
  let mut reg2_map : HashMap <String, String> = HashMap::new();
  reg2_map.insert(String::from("layout"), String::from("ipv4_t"));
  reg2_map.insert(String::from("direct"), String::from("ipv4_routing"));
  register_map.insert(String::from("reg1"), reg1_map);
  register_map.insert(String::from("reg2"), reg2_map);
  register_map
}
pub fn call_action (action : &str, args : Vec<i32>, pkt : &mut Packet, memories : &mut StatefulMemories) {
  match action {
    "drop_pkt" => drop_pkt(pkt, memories),
    "hop_ipv4" => hop_ipv4(args[0], pkt, memories),
    "act" => act(pkt, memories),
    _ => panic!("Error: Invalid action provided to call_action function"),
  };
}
fn drop(p : &mut Packet) {
  p.drop();
}
fn modify_field (pkt_field : &mut i32, value : i32) {
  *pkt_field = value;
}
fn add_to_field (pkt_field : &mut i32, value : i32) {
  *pkt_field += value;
}
fn count (c : &mut StatefulMemory, value : i32) {
  c[value] += value; 
}
pub fn generate_schedule() -> HashMap <i32, Vec<String>> {
  let mut schedule : HashMap <i32, Vec<String>> = HashMap::new();
  schedule
}
